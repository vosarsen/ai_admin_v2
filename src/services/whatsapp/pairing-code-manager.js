// src/services/whatsapp/pairing-code-manager.js
const { supabase } = require('../../database/supabase');
const logger = require('../../utils/logger');
const { redisClient } = require('../../utils/redis-factory');
const EventEmitter = require('events');

/**
 * Multi-tenant Pairing Code Manager
 * Управляет pairing code для каждой компании изолированно
 */
class PairingCodeManager extends EventEmitter {
  constructor() {
    super();
    this.pendingCodes = new Map(); // companyId -> { code, phoneNumber, expiresAt }
    this.codeAttempts = new Map(); // companyId -> attempts count
    this.lastAttemptTime = new Map(); // companyId -> timestamp

    // Rate limiting configuration
    this.config = {
      maxAttemptsPerHour: 5,
      cooldownMinutes: 30,
      codeValiditySeconds: 60,
      maxQRBeforePairing: 3
    };
  }

  /**
   * Check if company should use pairing code instead of QR
   */
  async shouldUsePairingCode(companyId) {
    try {
      // Check QR generation count from Redis
      const qrCount = await redisClient.get(`whatsapp:qr_count:${companyId}`);
      if (parseInt(qrCount) >= this.config.maxQRBeforePairing) {
        logger.info(`Company ${companyId} reached QR limit (${qrCount}), should use pairing code`);
        return true;
      }

      // Check if company has pairing preference
      const { data: company } = await supabase
        .from('companies')
        .select('whatsapp_config')
        .eq('company_id', companyId)
        .single();

      return company?.whatsapp_config?.usePairingCode || false;
    } catch (error) {
      logger.error(`Error checking pairing code preference: ${error.message}`);
      return false;
    }
  }

  /**
   * Check rate limiting for pairing code generation
   */
  canGenerateCode(companyId) {
    const attempts = this.codeAttempts.get(companyId) || 0;
    const lastTime = this.lastAttemptTime.get(companyId) || 0;
    const timeSinceLastAttempt = Date.now() - lastTime;

    // Reset counter if more than 1 hour passed
    if (timeSinceLastAttempt > 3600000) {
      this.codeAttempts.set(companyId, 0);
      return true;
    }

    // Check if under limit
    if (attempts >= this.config.maxAttemptsPerHour) {
      const minutesLeft = Math.ceil((this.config.cooldownMinutes * 60000 - timeSinceLastAttempt) / 60000);
      return {
        allowed: false,
        reason: 'rate_limit',
        minutesLeft
      };
    }

    return true;
  }

  /**
   * Generate pairing code for company
   */
  async generatePairingCode(companyId, phoneNumber) {
    // Check rate limiting
    const canGenerate = this.canGenerateCode(companyId);
    if (canGenerate !== true) {
      throw new Error(`Rate limit reached. Please wait ${canGenerate.minutesLeft} minutes.`);
    }

    // Get company details
    const { data: company, error } = await supabase
      .from('companies')
      .select('company_id, title, phone, owner_email')
      .eq('company_id', companyId)
      .single();

    if (error || !company) {
      throw new Error(`Company ${companyId} not found`);
    }

    // Update attempt counter
    const attempts = (this.codeAttempts.get(companyId) || 0) + 1;
    this.codeAttempts.set(companyId, attempts);
    this.lastAttemptTime.set(companyId, Date.now());

    // Generate code (will be generated by Baileys provider)
    const codeInfo = {
      companyId,
      companyName: company.title,
      phoneNumber,
      requestedAt: new Date(),
      expiresAt: new Date(Date.now() + this.config.codeValiditySeconds * 1000),
      attempts
    };

    // Store in memory
    this.pendingCodes.set(companyId, codeInfo);

    // Store in Redis with expiration
    await redisClient.setex(
      `whatsapp:pairing:${companyId}`,
      this.config.codeValiditySeconds,
      JSON.stringify(codeInfo)
    );

    // Log event
    await this.logPairingEvent(companyId, 'code_requested', codeInfo);

    // Emit event for monitoring
    this.emit('code-requested', codeInfo);

    return codeInfo;
  }

  /**
   * Store generated pairing code
   */
  async storePairingCode(companyId, code) {
    const codeInfo = this.pendingCodes.get(companyId);
    if (!codeInfo) {
      logger.warn(`No pending code info for company ${companyId}`);
      return;
    }

    codeInfo.code = code;
    codeInfo.formattedCode = code.match(/.{1,4}/g)?.join('-') || code;

    // Update in Redis
    await redisClient.setex(
      `whatsapp:pairing:${companyId}`,
      this.config.codeValiditySeconds,
      JSON.stringify(codeInfo)
    );

    // Store in database for history
    await supabase
      .from('whatsapp_pairing_codes')
      .insert({
        company_id: companyId,
        phone_number: codeInfo.phoneNumber,
        code: codeInfo.formattedCode,
        expires_at: codeInfo.expiresAt,
        status: 'pending'
      });

    // Send notification to company
    await this.notifyCompany(companyId, codeInfo);

    // Log event
    await this.logPairingEvent(companyId, 'code_generated', { code: codeInfo.formattedCode });

    this.emit('code-generated', codeInfo);

    return codeInfo;
  }

  /**
   * Mark pairing code as used
   */
  async markCodeUsed(companyId) {
    const codeInfo = this.pendingCodes.get(companyId);

    if (codeInfo) {
      // Update database
      await supabase
        .from('whatsapp_pairing_codes')
        .update({
          status: 'used',
          used_at: new Date()
        })
        .eq('company_id', companyId)
        .eq('code', codeInfo.formattedCode);

      // Clear from memory
      this.pendingCodes.delete(companyId);

      // Clear from Redis
      await redisClient.del(`whatsapp:pairing:${companyId}`);

      // Reset QR counter
      await redisClient.del(`whatsapp:qr_count:${companyId}`);

      // Log event
      await this.logPairingEvent(companyId, 'code_used', { code: codeInfo.formattedCode });

      this.emit('code-used', { companyId, code: codeInfo.formattedCode });
    }
  }

  /**
   * Get pending pairing code for company
   */
  async getPendingCode(companyId) {
    // Check memory first
    let codeInfo = this.pendingCodes.get(companyId);

    if (!codeInfo) {
      // Check Redis
      const redisData = await redisClient.get(`whatsapp:pairing:${companyId}`);
      if (redisData) {
        codeInfo = JSON.parse(redisData);
        this.pendingCodes.set(companyId, codeInfo);
      }
    }

    // Check if expired
    if (codeInfo && new Date(codeInfo.expiresAt) < new Date()) {
      this.pendingCodes.delete(companyId);
      await redisClient.del(`whatsapp:pairing:${companyId}`);
      return null;
    }

    return codeInfo;
  }

  /**
   * Notify company about pairing code
   */
  async notifyCompany(companyId, codeInfo) {
    try {
      // Get company notification preferences
      const { data: company } = await supabase
        .from('companies')
        .select('owner_email, notification_email, whatsapp_config')
        .eq('company_id', companyId)
        .single();

      if (!company) return;

      const notificationEmail = company.notification_email || company.owner_email;

      // Log notification (email sending would be implemented here)
      logger.info(`📧 Pairing code notification for company ${companyId}:`);
      logger.info(`  To: ${notificationEmail}`);
      logger.info(`  Code: ${codeInfo.formattedCode}`);
      logger.info(`  Phone: ${codeInfo.phoneNumber}`);
      logger.info(`  Expires: ${codeInfo.expiresAt}`);

      // Also send SMS if configured
      if (company.whatsapp_config?.smsNotifications) {
        logger.info(`📱 SMS notification would be sent to ${codeInfo.phoneNumber}`);
      }

    } catch (error) {
      logger.error(`Failed to notify company ${companyId}: ${error.message}`);
    }
  }

  /**
   * Log pairing event for audit
   */
  async logPairingEvent(companyId, eventType, details) {
    try {
      await supabase
        .from('whatsapp_events')
        .insert({
          company_id: companyId,
          event_type: `pairing_${eventType}`,
          details,
          created_at: new Date()
        });
    } catch (error) {
      logger.error(`Failed to log pairing event: ${error.message}`);
    }
  }

  /**
   * Get pairing statistics for company
   */
  async getCompanyStats(companyId) {
    const attempts = this.codeAttempts.get(companyId) || 0;
    const lastTime = this.lastAttemptTime.get(companyId);
    const pendingCode = await this.getPendingCode(companyId);

    // Get history from database
    const { data: history } = await supabase
      .from('whatsapp_pairing_codes')
      .select('*')
      .eq('company_id', companyId)
      .order('created_at', { ascending: false })
      .limit(10);

    return {
      currentAttempts: attempts,
      lastAttemptTime: lastTime ? new Date(lastTime) : null,
      pendingCode,
      history: history || [],
      canGenerate: this.canGenerateCode(companyId) === true
    };
  }

  /**
   * Clean up expired codes
   */
  async cleanupExpiredCodes() {
    for (const [companyId, codeInfo] of this.pendingCodes) {
      if (new Date(codeInfo.expiresAt) < new Date()) {
        this.pendingCodes.delete(companyId);
        await redisClient.del(`whatsapp:pairing:${companyId}`);

        // Update database
        await supabase
          .from('whatsapp_pairing_codes')
          .update({ status: 'expired' })
          .eq('company_id', companyId)
          .eq('code', codeInfo.formattedCode)
          .eq('status', 'pending');

        logger.info(`Cleaned up expired code for company ${companyId}`);
      }
    }
  }
}

// Export singleton
module.exports = new PairingCodeManager();