/**
 * Circuit Breaker Monitoring
 * –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è Circuit Breaker –¥–ª—è Redis –∏ –¥—Ä—É–≥–∏—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
 */

const EventEmitter = require('events');
const logger = require('../utils/logger');

class CircuitBreakerMonitor extends EventEmitter {
  constructor() {
    super();
    this.breakers = new Map();
    this.metrics = new Map();
    
    // –ò–Ω—Ç–µ—Ä–≤–∞–ª —Å–±–æ—Ä–∞ –º–µ—Ç—Ä–∏–∫
    this.metricsInterval = null;
    this.metricsIntervalMs = 60000; // 1 –º–∏–Ω—É—Ç–∞
    
    // –ê–ª–µ—Ä—Ç—ã
    this.alertThresholds = {
      errorRate: 0.5, // 50% –æ—à–∏–±–æ–∫
      openCircuits: 3, // 3+ –æ—Ç–∫—Ä—ã—Ç—ã—Ö circuit breaker
      halfOpenFailures: 5 // 5+ –Ω–µ—É–¥–∞—á–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ –≤ half-open
    };
  }

  /**
   * –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è Circuit Breaker –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
   */
  register(name, breaker) {
    this.breakers.set(name, breaker);
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç—Ä–∏–∫
    this.metrics.set(name, {
      totalCalls: 0,
      successCalls: 0,
      failedCalls: 0,
      openCount: 0,
      halfOpenCount: 0,
      closedCount: 0,
      lastStateChange: Date.now(),
      currentState: 'CLOSED',
      errorRate: 0,
      avgResponseTime: 0,
      p95ResponseTime: 0,
      p99ResponseTime: 0,
      responseTimes: []
    });
    
    // –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —Å–æ–±—ã—Ç–∏—è Circuit Breaker
    this._attachListeners(name, breaker);
    
    logger.info(`Circuit Breaker registered: ${name}`);
  }

  /**
   * –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —Å–æ–±—ã—Ç–∏—è Circuit Breaker
   */
  _attachListeners(name, breaker) {
    const metrics = this.metrics.get(name);
    
    // –£—Å–ø–µ—à–Ω—ã–π –≤—ã–∑–æ–≤
    breaker.on('success', (duration) => {
      metrics.totalCalls++;
      metrics.successCalls++;
      metrics.responseTimes.push(duration);
      this._updateResponseTimeMetrics(name);
      this.emit('call:success', { name, duration });
    });
    
    // –ù–µ—É–¥–∞—á–Ω—ã–π –≤—ã–∑–æ–≤
    breaker.on('failure', (error, duration) => {
      metrics.totalCalls++;
      metrics.failedCalls++;
      if (duration) {
        metrics.responseTimes.push(duration);
        this._updateResponseTimeMetrics(name);
      }
      this.emit('call:failure', { name, error, duration });
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Ä–æ–≥–∞ –æ—à–∏–±–æ–∫
      this._checkErrorRate(name);
    });
    
    // –û—Ç–∫—Ä—ã—Ç–∏–µ Circuit Breaker
    breaker.on('open', () => {
      metrics.openCount++;
      metrics.currentState = 'OPEN';
      metrics.lastStateChange = Date.now();
      
      logger.warn(`Circuit Breaker OPENED: ${name}`);
      this.emit('state:open', { name });
      
      // –ê–ª–µ—Ä—Ç –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏
      this._sendAlert('circuit_open', {
        name,
        message: `Circuit Breaker ${name} is now OPEN`
      });
    });
    
    // –ü–µ—Ä–µ—Ö–æ–¥ –≤ half-open
    breaker.on('halfOpen', () => {
      metrics.halfOpenCount++;
      metrics.currentState = 'HALF_OPEN';
      metrics.lastStateChange = Date.now();
      
      logger.info(`Circuit Breaker HALF-OPEN: ${name}`);
      this.emit('state:halfOpen', { name });
    });
    
    // –ó–∞–∫—Ä—ã—Ç–∏–µ Circuit Breaker
    breaker.on('close', () => {
      metrics.closedCount++;
      metrics.currentState = 'CLOSED';
      metrics.lastStateChange = Date.now();
      
      logger.info(`Circuit Breaker CLOSED: ${name}`);
      this.emit('state:closed', { name });
    });
    
    // –¢–∞–π–º–∞—É—Ç
    breaker.on('timeout', () => {
      logger.warn(`Circuit Breaker TIMEOUT: ${name}`);
      this.emit('timeout', { name });
    });
  }

  /**
   * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫ –≤—Ä–µ–º–µ–Ω–∏ –æ—Ç–≤–µ—Ç–∞
   */
  _updateResponseTimeMetrics(name) {
    const metrics = this.metrics.get(name);
    const times = metrics.responseTimes.slice(-1000); // –ü–æ—Å–ª–µ–¥–Ω–∏–µ 1000 –∏–∑–º–µ—Ä–µ–Ω–∏–π
    
    if (times.length === 0) return;
    
    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –¥–ª—è –ø–µ—Ä—Å–µ–Ω—Ç–∏–ª–µ–π
    const sorted = times.sort((a, b) => a - b);
    
    // –°—Ä–µ–¥–µ–µ –≤—Ä–µ–º—è
    metrics.avgResponseTime = times.reduce((a, b) => a + b, 0) / times.length;
    
    // P95
    const p95Index = Math.floor(sorted.length * 0.95);
    metrics.p95ResponseTime = sorted[p95Index];
    
    // P99
    const p99Index = Math.floor(sorted.length * 0.99);
    metrics.p99ResponseTime = sorted[p99Index];
    
    // –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    if (metrics.responseTimes.length > 1000) {
      metrics.responseTimes = times;
    }
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—Ü–µ–Ω—Ç–∞ –æ—à–∏–±–æ–∫
   */
  _checkErrorRate(name) {
    const metrics = this.metrics.get(name);
    
    if (metrics.totalCalls > 0) {
      metrics.errorRate = metrics.failedCalls / metrics.totalCalls;
      
      if (metrics.errorRate > this.alertThresholds.errorRate) {
        this._sendAlert('high_error_rate', {
          name,
          errorRate: metrics.errorRate,
          message: `High error rate for ${name}: ${(metrics.errorRate * 100).toFixed(2)}%`
        });
      }
    }
  }

  /**
   * –û—Ç–ø—Ä–∞–≤–∫–∞ –∞–ª–µ—Ä—Ç–∞
   */
  _sendAlert(type, data) {
    logger.error(`üö® ALERT [${type}]:`, data);
    this.emit('alert', { type, ...data });
    
    // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É –≤ Slack, PagerDuty, etc.
  }

  /**
   * –ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
   */
  start() {
    if (this.metricsInterval) {
      return;
    }
    
    this.metricsInterval = setInterval(() => {
      this._collectMetrics();
    }, this.metricsIntervalMs);
    
    logger.info('Circuit Breaker monitoring started');
  }

  /**
   * –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
   */
  stop() {
    if (this.metricsInterval) {
      clearInterval(this.metricsInterval);
      this.metricsInterval = null;
    }
    
    logger.info('Circuit Breaker monitoring stopped');
  }

  /**
   * –°–±–æ—Ä –º–µ—Ç—Ä–∏–∫
   */
  _collectMetrics() {
    const summary = {
      timestamp: Date.now(),
      breakers: []
    };
    
    let openCount = 0;
    
    for (const [name, metrics] of this.metrics) {
      const breakerStats = {
        name,
        state: metrics.currentState,
        totalCalls: metrics.totalCalls,
        successRate: metrics.totalCalls > 0 
          ? ((metrics.successCalls / metrics.totalCalls) * 100).toFixed(2) + '%'
          : '0%',
        errorRate: (metrics.errorRate * 100).toFixed(2) + '%',
        avgResponseTime: Math.round(metrics.avgResponseTime),
        p95ResponseTime: Math.round(metrics.p95ResponseTime),
        p99ResponseTime: Math.round(metrics.p99ResponseTime),
        stateChanges: {
          open: metrics.openCount,
          halfOpen: metrics.halfOpenCount,
          closed: metrics.closedCount
        }
      };
      
      summary.breakers.push(breakerStats);
      
      if (metrics.currentState === 'OPEN') {
        openCount++;
      }
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö Circuit Breakers
    if (openCount >= this.alertThresholds.openCircuits) {
      this._sendAlert('multiple_circuits_open', {
        count: openCount,
        message: `${openCount} Circuit Breakers are OPEN`
      });
    }
    
    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–≤–æ–¥–∫–∏
    logger.debug('Circuit Breaker metrics:', summary);
    
    // Emit –¥–ª—è –≤–Ω–µ—à–Ω–∏—Ö —Å–∏—Å—Ç–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
    this.emit('metrics', summary);
    
    return summary;
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–∏—Ö –º–µ—Ç—Ä–∏–∫
   */
  getMetrics(name = null) {
    if (name) {
      return this.metrics.get(name);
    }
    
    const result = {};
    for (const [key, value] of this.metrics) {
      result[key] = value;
    }
    return result;
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –≤—Å–µ—Ö Circuit Breakers
   */
  getStatus() {
    const status = {
      healthy: true,
      breakers: {}
    };
    
    for (const [name, metrics] of this.metrics) {
      status.breakers[name] = {
        state: metrics.currentState,
        healthy: metrics.currentState !== 'OPEN',
        errorRate: metrics.errorRate,
        lastStateChange: new Date(metrics.lastStateChange).toISOString()
      };
      
      if (metrics.currentState === 'OPEN') {
        status.healthy = false;
      }
    }
    
    return status;
  }

  /**
   * –°–±—Ä–æ—Å –º–µ—Ç—Ä–∏–∫
   */
  resetMetrics(name = null) {
    if (name) {
      const metrics = this.metrics.get(name);
      if (metrics) {
        metrics.totalCalls = 0;
        metrics.successCalls = 0;
        metrics.failedCalls = 0;
        metrics.errorRate = 0;
        metrics.responseTimes = [];
        metrics.avgResponseTime = 0;
        metrics.p95ResponseTime = 0;
        metrics.p99ResponseTime = 0;
      }
    } else {
      // –°–±—Ä–æ—Å –≤—Å–µ—Ö –º–µ—Ç—Ä–∏–∫
      for (const metrics of this.metrics.values()) {
        metrics.totalCalls = 0;
        metrics.successCalls = 0;
        metrics.failedCalls = 0;
        metrics.errorRate = 0;
        metrics.responseTimes = [];
        metrics.avgResponseTime = 0;
        metrics.p95ResponseTime = 0;
        metrics.p99ResponseTime = 0;
      }
    }
    
    logger.info(`Metrics reset for: ${name || 'all breakers'}`);
  }

  /**
   * –≠–∫—Å–ø–æ—Ä—Ç –º–µ—Ç—Ä–∏–∫ –¥–ª—è Prometheus
   */
  getPrometheusMetrics() {
    const lines = [];
    
    // Headers
    lines.push('# HELP circuit_breaker_state Circuit breaker state (0=closed, 1=half-open, 2=open)');
    lines.push('# TYPE circuit_breaker_state gauge');
    
    lines.push('# HELP circuit_breaker_total_calls Total number of calls');
    lines.push('# TYPE circuit_breaker_total_calls counter');
    
    lines.push('# HELP circuit_breaker_success_calls Successful calls');
    lines.push('# TYPE circuit_breaker_success_calls counter');
    
    lines.push('# HELP circuit_breaker_failed_calls Failed calls');
    lines.push('# TYPE circuit_breaker_failed_calls counter');
    
    lines.push('# HELP circuit_breaker_response_time Response time in milliseconds');
    lines.push('# TYPE circuit_breaker_response_time histogram');
    
    // Metrics
    for (const [name, metrics] of this.metrics) {
      const labels = `{name="${name}"}`;
      
      // State (0=closed, 1=half-open, 2=open)
      const stateValue = metrics.currentState === 'CLOSED' ? 0 : 
                         metrics.currentState === 'HALF_OPEN' ? 1 : 2;
      lines.push(`circuit_breaker_state${labels} ${stateValue}`);
      
      // Counters
      lines.push(`circuit_breaker_total_calls${labels} ${metrics.totalCalls}`);
      lines.push(`circuit_breaker_success_calls${labels} ${metrics.successCalls}`);
      lines.push(`circuit_breaker_failed_calls${labels} ${metrics.failedCalls}`);
      
      // Response times
      if (metrics.avgResponseTime > 0) {
        lines.push(`circuit_breaker_response_time${labels}{quantile="0.5"} ${metrics.avgResponseTime}`);
        lines.push(`circuit_breaker_response_time${labels}{quantile="0.95"} ${metrics.p95ResponseTime}`);
        lines.push(`circuit_breaker_response_time${labels}{quantile="0.99"} ${metrics.p99ResponseTime}`);
      }
    }
    
    return lines.join('\n');
  }
}

// Singleton
let instance = null;

module.exports = {
  getInstance() {
    if (!instance) {
      instance = new CircuitBreakerMonitor();
    }
    return instance;
  },
  
  CircuitBreakerMonitor
};