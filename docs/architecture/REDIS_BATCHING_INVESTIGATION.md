# Исследование проблемы Redis батчинга

## Обзор проблемы

### Симптомы
1. Сообщения, отправленные быстро (rapid-fire), не объединяются в один батч
2. Батчи исчезают из Redis через 0.5-11 секунд вместо запланированных 60 секунд
3. Batch processor не видит батчи, созданные API сервером
4. Пользователи не получают ответы на сообщения, отправленные по частям

### Ожидаемое поведение
1. Несколько сообщений от одного пользователя должны объединяться в один батч
2. Батч должен обрабатываться через 10 секунд после последнего сообщения
3. TTL батча должен быть 60 секунд

## Архитектура системы

### Компоненты
1. **API сервер** (ai-admin-api) - принимает webhook от WhatsApp
2. **Batch processor** (ai-admin-batch-processor) - обрабатывает батчи
3. **Redis** - хранит батчи сообщений
4. **Worker v2** - обрабатывает объединенные сообщения

### Поток данных
```
WhatsApp → Webhook → API Server → Redis Batch → Batch Processor → Message Queue → Worker v2
```

## Проведенное исследование

### 1. Анализ логов
- API сервер успешно добавляет сообщения в батчи
- Batch processor не находит батчи при проверке
- TTL батчей уменьшается аномально быстро

### 2. Тестирование Redis подключений
```javascript
// Тест показал, что оба процесса используют:
- Порт: 6379
- База данных: 0
- Пароль: одинаковый
```

### 3. Изоляционные тесты
- **С выключенным batch processor**: батчи сохраняются и имеют корректный TTL
- **С включенным batch processor**: батчи исчезают мгновенно
- **Вывод**: batch processor каким-то образом удаляет батчи

### 4. Анализ кода
- Найдена логика, которая обрабатывает батчи без lastMessageTime немедленно
- Исправлена логика - батчи без lastMessageTime теперь пропускаются
- **Результат**: проблема не решена

### 5. Проверка временного фикса портов
- API использует порт 6380 с переопределением на 6379
- Создана централизованная конфигурация Redis
- **Результат**: проблема не решена

## Ключевые находки

### 1. Процессы видят разные данные
```
API Server: добавляет ключ rapid-fire:79936363848@c.us
Batch Processor: не видит этот ключ
```

### 2. TTL не соблюдается
```
Ожидаемое: TTL = 60 секунд
Фактическое: TTL истекает за 10-11 секунд
```

### 3. Батчинг работает в изоляции
- Тесты в одном процессе работают корректно
- Проблема проявляется только в production с PM2

## Попытки решения

### 1. Исправление логики shouldProcessBatch
```javascript
// Было: обрабатывать батч без lastMessageTime
if (!lastMessageTime) {
  return exists > 0;
}

// Стало: пропускать батч без lastMessageTime
if (!lastMessageTime) {
  return false;
}
```
**Результат**: Не помогло

### 2. Централизованная конфигурация Redis
```javascript
// src/config/redis-config.js
function getRedisConfig() {
  return {
    host: 'localhost',
    port: 6379,
    db: 0,
    password: process.env.REDIS_PASSWORD
  };
}
```
**Результат**: Не помогло

### 3. Добавление задержки при инициализации
```javascript
await new Promise(resolve => setTimeout(resolve, 2000));
```
**Результат**: Не тестировалось

## Гипотезы о причинах

### 1. Race condition между процессами
- API и batch processor конкурируют за доступ к ключам
- Возможно, есть проблема с атомарностью операций

### 2. Проблема с Redis клиентом
- ioredis может иметь проблемы с синхронизацией между процессами
- Возможно, используются разные пулы соединений

### 3. Особенность PM2
- PM2 может изолировать процессы друг от друга
- Возможно, есть проблема с переменными окружения

### 4. Проблема с базой данных Redis
- Хотя оба процесса указывают db=0, возможно есть скрытая проблема
- Redis может использовать разные namespace для разных клиентов

## Рекомендации

### Краткосрочные решения

1. **Отключить батчинг** (рекомендуется)
   - Вернуться к webhook `/webhook/whatsapp`
   - Обрабатывать каждое сообщение отдельно
   - Простое и надежное решение

2. **Увеличить TTL**
   - Установить defaultTTL = 120-180 секунд
   - Может частично смягчить проблему

### Долгосрочные решения

1. **In-memory батчинг**
   ```javascript
   class InMemoryBatchService {
     constructor() {
       this.batches = new Map();
       this.timers = new Map();
     }
   }
   ```

2. **Использовать BullMQ**
   - Создать специальную очередь для батчей
   - BullMQ уже используется и работает стабильно

3. **Redis Pub/Sub**
   - Использовать pub/sub для синхронизации между процессами
   - API публикует события, batch processor подписывается

## Уроки

1. **Сложность распределенных систем**: Простая на вид задача может иметь скрытые сложности
2. **Важность изоляционного тестирования**: Проблема проявляется только в production окружении
3. **Батчинг - это оптимизация**: Система должна работать и без него
4. **PM2 и multi-process**: Нужно учитывать особенности работы с несколькими процессами

## Заключение

Проблема с Redis батчингом оказалась сложнее, чем ожидалось. Несмотря на множество попыток, стабильное решение не найдено. Рекомендуется временно отключить батчинг и использовать прямую обработку сообщений, пока не будет найдено надежное решение.

## Приложения

### Тестовые скрипты
- `test-redis-batch.js` - базовый тест батчинга
- `test-redis-isolation.js` - тест изоляции процессов
- `test-redis-ttl.js` - тест поведения TTL
- `test-redis-connections.js` - тест подключений
- `test-redis-race.js` - тест race conditions

### Логи для анализа
```bash
# Просмотр логов API
pm2 logs ai-admin-api --lines 100

# Просмотр логов batch processor
pm2 logs ai-admin-batch-processor --lines 100

# Поиск проблем с TTL
grep "TTL is very low" /opt/ai-admin/logs/batch-processor-out-3.log
```