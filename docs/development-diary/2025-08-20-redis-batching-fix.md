# Исправление критической проблемы с Redis батчингом

**Дата**: 20 августа 2025  
**Автор**: AI Admin Team  
**Проблема**: Сообщения не обрабатывались через систему батчинга  
**Статус**: ✅ Решено

## Описание проблемы

### Симптомы
1. Клиенты получали ответы от бота, но не от нашей системы AI Admin v2
2. Сообщения добавлялись в Redis батчи, но batch processor их не находил
3. В логах API: `Found rapid-fire keys: 1, keys: rapid-fire:+79686484488`
4. В логах batch processor: `No pending batches found`
5. Ключи Redis "исчезали" между созданием и обработкой

### Временная шкала проблемы
- **7:40-7:50** - Диалог с клиентом Евгением Поповым (79263072146)
- API получал сообщения и добавлял в Redis
- Batch processor не видел ключи
- Клиент получал ответы от неизвестного источника

## Техническое расследование

### Первоначальные гипотезы
1. ❌ **TTL слишком короткий** - увеличили с 120 до 600 секунд
2. ❌ **Разные Redis базы данных** - проверили, используется одна БД
3. ❌ **Проблемы с нормализацией телефонов** - номера нормализуются корректно
4. ✅ **Кэширование модулей в Node.js** - НАСТОЯЩАЯ ПРИЧИНА

### Корневая причина

**Проблема**: Кэширование singleton экземпляра `redis-batch-service` в Node.js

#### Как работает require() в Node.js:
```javascript
// При ПЕРВОМ require модуль загружается и кэшируется
const batchService = require('../../services/redis-batch-service');

// Все последующие require возвращают ТОТ ЖЕ экземпляр из кэша
// Даже если файл на диске изменился!
```

#### Что происходило в нашем случае:

1. **Файл `src/api/webhooks/whatsapp-batched.js`**:
```javascript
// Загружается ОДИН РАЗ при старте API
const batchService = require('../../services/redis-batch-service');

// Инициализация при загрузке модуля
(async () => {
  await batchService.initialize(); // Использует TTL из конструктора
})();
```

2. **Класс `RedisBatchService`**:
```javascript
class RedisBatchService {
  constructor() {
    this.defaultTTL = 120; // Значение на момент ПЕРВОЙ загрузки
  }
}

// Singleton экземпляр
const batchService = new RedisBatchService();
module.exports = batchService;
```

3. **Хронология событий**:
   - API запущен с `TTL=120` (старое значение)
   - Мы изменили код на `TTL=600`
   - Сделали `git pull` на сервере
   - Сделали `pm2 restart` - процесс перезапустился
   - **НО!** Модуль остался в кэше с `TTL=120`
   - API создавал ключи с TTL=120 (из кэша)
   - Batch processor читал код с диска с TTL=600
   - Ключи истекали до обработки

## Решение

### Правильная последовательность действий:

1. **Изменить код**:
```javascript
this.defaultTTL = 600; // Новое значение
```

2. **Деплой на сервер**:
```bash
git pull
```

3. **ВАЖНО: Использовать `reload`, а не `restart`**:
```bash
# ❌ НЕПРАВИЛЬНО - не очищает кэш модулей
pm2 restart ai-admin-api

# ✅ ПРАВИЛЬНО - полная перезагрузка с очисткой кэша
pm2 reload ai-admin-api
```

### Разница между restart и reload:

| Команда | Действие | Кэш модулей | Когда использовать |
|---------|----------|-------------|-------------------|
| `pm2 restart` | Убивает и запускает процесс | Может сохраниться | Для быстрого перезапуска |
| `pm2 reload` | Graceful reload с новым worker | Очищается | При изменении singleton сервисов |
| `pm2 stop && pm2 start` | Полная остановка и запуск | Очищается | При критических изменениях |

## Дополнительные находки

### 1. Система работает с двумя ботами
- **AI Admin v2** - наша система (не работала из-за батчинга)
- **Неизвестный бот** - отвечал клиентам когда наша система не работала
- Требуется дополнительное расследование источника вторых ответов

### 2. Оптимальные настройки батчинга
```javascript
this.defaultTTL = 120;      // 2 минуты - оптимально
this.batchTimeout = 9000;   // 9 секунд ожидания
this.maxBatchSize = 10;     // максимум сообщений
```

- **120 секунд достаточно** для батчинга
- Проблема была не в времени, а в кэшировании
- 60 секунд может быть мало при сбоях
- 600 секунд избыточно, тратит память Redis

## Уроки и рекомендации

### 1. Диагностика Redis
```javascript
// Добавлен код для диагностики при старте batch processor
const allKeys = await batchService.redis.keys('*');
const rapidKeys = allKeys.filter(k => k.includes('rapid'));
logger.info(`Initial Redis scan: total ${allKeys.length} keys, rapid-fire: ${rapidKeys.length}`);
```

### 2. Логирование TTL
```javascript
logger.info(`EXPIRE executed - batch: ${ttl1}, lastMsg: ${ttl2}, TTL: ${this.defaultTTL}`);
```

### 3. Процедура деплоя singleton сервисов
1. Изменить код локально
2. Commit и push
3. На сервере: `git pull`
4. **ОБЯЗАТЕЛЬНО**: `pm2 reload` (не restart!)
5. Проверить логи на правильные значения

### 4. Мониторинг батчинга
- Проверять что ключи создаются: `Found rapid-fire keys`
- Проверять что batch processor их видит: `Found N pending batches`
- Проверять TTL в логах: `TTL: 120`

## Тестирование исправления

### Тестовый сценарий:
```javascript
// Отправка тестового сообщения
await mcp.whatsapp.send_message({
  phone: "79686484488",
  message: "Тестовое сообщение для проверки батчинга"
});

// Ожидание 10 секунд для батчинга
await sleep(10000);

// Проверка логов
// ✅ API: "EXPIRE executed - TTL: 120"
// ✅ Batch processor: "Processing batch for +79686484488"
// ✅ Worker: "Message from +79686484488"
// ✅ Venom: "Message sent successfully"
```

### Результат:
- Сообщения успешно батчатся
- Обрабатываются через 9 секунд
- Отправляются в очередь BullMQ
- Worker обрабатывает и отправляет ответ

## Влияние на продукт

### До исправления:
- ❌ Батчинг не работал
- ❌ Сообщения обрабатывались по одному или не обрабатывались
- ❌ Клиенты получали ответы от другой системы

### После исправления:
- ✅ Батчинг работает корректно
- ✅ Сообщения объединяются за 9 секунд
- ✅ Экономия ресурсов AI (один запрос вместо нескольких)
- ✅ Лучшее понимание контекста

## Заключение

Критическая проблема с батчингом была вызвана не ошибкой в логике или недостаточным TTL, а особенностью работы Node.js с кэшированием модулей. Это важный урок о том, что при работе с singleton сервисами необходимо использовать `pm2 reload` для полной перезагрузки приложения.

**Ключевое правило**: При изменении singleton сервисов, конфигураций или глобальных объектов всегда используйте `pm2 reload`, а не `pm2 restart`.