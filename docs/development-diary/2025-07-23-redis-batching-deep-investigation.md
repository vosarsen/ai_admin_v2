# Глубокое исследование проблемы Redis батчинга - 23 июля 2025

## Контекст
После реализации Redis-based батчинга для решения проблемы rapid-fire protection, обнаружилась критическая проблема: батчи исчезали преждевременно, и пользователи не получали ответы на сообщения, отправленные по частям.

## Что было сделано

### 1. Первоначальная диагностика (15:00-16:00)
- Обнаружено, что батчи исчезают через 0.5-11 секунд вместо 60
- Выявлена проблема с логикой обработки батчей без lastMessageTime
- Реализовано исправление в `shouldProcessBatch`

### 2. Глубокое исследование (18:00-19:30)
- Проведен полный code review процесса батчинга
- Создано множество изоляционных тестов
- Обнаружено, что батчи работают корректно без batch processor

### 3. Ключевые тесты и их результаты

#### test-redis-isolation.js
```javascript
// API процесс: создает ключ rapid-fire:test-isolation
// Batch processor: не видит этот ключ
// Вывод: процессы видят разные данные
```

#### test-redis-info.js
```javascript
// Оба процесса используют:
// - Redis версия: 7.0.15
// - Порт: 6379
// - База данных: 0
// Вывод: конфигурация одинаковая
```

#### test-redis-ttl.js
```javascript
// EXPIRE корректно обновляет TTL
// Вывод: проблема не в Redis командах
```

### 4. Попытки решения

#### Попытка 1: Исправление логики
- Изменена логика обработки батчей без lastMessageTime
- Результат: проблема не решена

#### Попытка 2: Централизованная конфигурация
- Создан `redis-config.js` с единой конфигурацией
- Результат: проблема не решена

#### Попытка 3: Добавление задержки
- Добавлена 2-секундная задержка при инициализации
- Результат: не тестировалось

## Технические детали

### Архитектура проблемы
```
1. API Server (PID 14829) создает батч в Redis
2. Batch Processor (PID 14837) не видит этот батч
3. Оба используют одинаковую конфигурацию Redis
4. Проблема проявляется только с PM2 в production
```

### Ключевая находка
При выключенном batch processor батчи сохраняются корректно с правильным TTL. При включении - исчезают мгновенно.

## Проблемы и решения

### Проблема 1: Процессы не видят данные друг друга
**Попытки решения**:
- Проверка конфигурации Redis
- Создание централизованной конфигурации
- Явное указание базы данных 0

**Результат**: Не решено

### Проблема 2: TTL истекает преждевременно
**Анализ**:
- TTL устанавливается от первого сообщения
- К моменту обработки (через 10 секунд) TTL почти истек
- EXPIRE должен обновлять TTL, но этого не происходит

**Результат**: Причина не найдена

## Извлеченные уроки

1. **Сложность multi-process архитектуры**
   - PM2 процессы могут иметь неочевидные проблемы с общими ресурсами
   - Singleton паттерн не работает между процессами

2. **Важность изоляционного тестирования**
   - Проблема не воспроизводится в изолированных тестах
   - Production окружение может значительно отличаться

3. **Батчинг как источник сложности**
   - Простая оптимизация привела к сложной проблеме
   - Система должна работать и без оптимизаций

4. **Ограничения Redis в multi-process**
   - Возможны скрытые проблемы с синхронизацией
   - Race conditions сложно отлаживать

## Рекомендации на будущее

1. **Для батчинга сообщений**:
   - Рассмотреть in-memory решение в рамках одного процесса
   - Использовать BullMQ, который уже работает стабильно
   - Избегать сложных multi-process взаимодействий

2. **Для архитектуры**:
   - Минимизировать зависимости между PM2 процессами
   - Использовать message passing вместо shared state
   - Добавить подробное логирование всех Redis операций

3. **Для отладки**:
   - Создавать воспроизводимые тесты
   - Использовать Redis MONITOR для отслеживания команд
   - Добавлять уникальные идентификаторы процессов в логи

## Итоги

Потрачено около 4 часов на глубокое исследование проблемы. Хотя окончательное решение не найдено, получено глубокое понимание проблемы и созданы инструменты для дальнейшей отладки. Рекомендуется временно отключить батчинг для стабильной работы системы.

## Следующие шаги

1. Временно отключить батчинг в production
2. Реализовать альтернативное решение (in-memory или BullMQ)
3. Провести нагрузочное тестирование без батчинга
4. Документировать результаты для команды